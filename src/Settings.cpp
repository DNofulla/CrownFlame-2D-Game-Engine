#include "Settings.h"
#include <filesystem>
#include <iostream>


Settings::Settings(const std::string &filename) : settingsFile(filename) {
  load();
}

Settings::~Settings() { save(); }

void Settings::createDefaultSettings() {
  // Default window settings
  setSetting("window_width", 800);
  setSetting("window_height", 600);
  setSetting("window_x", 100);
  setSetting("window_y", 100);
  setSetting("last_monitor_index", -1); // -1 means primary monitor
  setSetting("first_run", true);
}

bool Settings::loadFromFile() {
  std::ifstream file(settingsFile);
  if (!file.is_open()) {
    return false;
  }

  settings.clear();
  std::string line;
  while (std::getline(file, line)) {
    // Skip empty lines and comments
    if (line.empty() || line[0] == '#') {
      continue;
    }

    // Find the '=' separator
    size_t equalPos = line.find('=');
    if (equalPos != std::string::npos) {
      std::string key = line.substr(0, equalPos);
      std::string value = line.substr(equalPos + 1);

      // Trim whitespace
      key.erase(0, key.find_first_not_of(" \t"));
      key.erase(key.find_last_not_of(" \t") + 1);
      value.erase(0, value.find_first_not_of(" \t"));
      value.erase(value.find_last_not_of(" \t") + 1);

      settings[key] = value;
    }
  }

  file.close();
  return true;
}

bool Settings::saveToFile() {
  // Create directory if it doesn't exist
  std::filesystem::path filePath(settingsFile);
  std::filesystem::path dirPath = filePath.parent_path();

  if (!dirPath.empty() && !std::filesystem::exists(dirPath)) {
    std::filesystem::create_directories(dirPath);
  }

  std::ofstream file(settingsFile);
  if (!file.is_open()) {
    std::cerr << "Failed to save settings to: " << settingsFile << std::endl;
    return false;
  }

  file << "# CrownFlame 2D Game Engine Settings\n";
  file << "# This file is automatically generated\n\n";

  for (const auto &pair : settings) {
    file << pair.first << "=" << pair.second << "\n";
  }

  file.close();
  return true;
}

void Settings::saveMonitorSettings(GLFWwindow *window) {
  if (!window)
    return;

  // Get current window position
  int windowX, windowY;
  glfwGetWindowPos(window, &windowX, &windowY);

  // Get current window size
  int windowWidth, windowHeight;
  glfwGetWindowSize(window, &windowWidth, &windowHeight);

  // Find which monitor the window is primarily on
  int monitorCount;
  GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);

  int bestMonitorIndex = -1;
  int maxOverlap = 0;

  for (int i = 0; i < monitorCount; i++) {
    const GLFWvidmode *mode = glfwGetVideoMode(monitors[i]);
    int monitorX, monitorY;
    glfwGetMonitorPos(monitors[i], &monitorX, &monitorY);

    // Calculate overlap between window and monitor
    int overlapLeft = std::max(windowX, monitorX);
    int overlapTop = std::max(windowY, monitorY);
    int overlapRight = std::min(windowX + windowWidth, monitorX + mode->width);
    int overlapBottom =
        std::min(windowY + windowHeight, monitorY + mode->height);

    if (overlapRight > overlapLeft && overlapBottom > overlapTop) {
      int overlapArea =
          (overlapRight - overlapLeft) * (overlapBottom - overlapTop);
      if (overlapArea > maxOverlap) {
        maxOverlap = overlapArea;
        bestMonitorIndex = i;
      }
    }
  }

  // Save the monitor index and window state
  setLastMonitorIndex(bestMonitorIndex);
  saveWindowSettings(windowWidth, windowHeight, windowX, windowY);

  std::cout << "Saved monitor settings: Monitor " << bestMonitorIndex
            << ", Position (" << windowX << ", " << windowY << "), Size ("
            << windowWidth << "x" << windowHeight << ")" << std::endl;
}

bool Settings::restoreMonitorSettings(GLFWwindow *window) {
  if (!window)
    return false;

  int lastMonitorIndex = getLastMonitorIndex();

  // If this is the first run or no monitor was saved, use default positioning
  if (getSetting("first_run", true) || lastMonitorIndex == -1) {
    setSetting("first_run", false);
    return false; // Let GLFW use default positioning
  }

  // Get monitor information
  int monitorCount;
  GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);

  // If the saved monitor index is invalid, use primary monitor
  if (lastMonitorIndex >= monitorCount) {
    lastMonitorIndex = 0; // Primary monitor
  }

  // Get the target monitor
  GLFWmonitor *targetMonitor = monitors[lastMonitorIndex];
  const GLFWvidmode *mode = glfwGetVideoMode(targetMonitor);
  int monitorX, monitorY;
  glfwGetMonitorPos(targetMonitor, &monitorX, &monitorY);

  // Get saved window settings
  int savedWidth, savedHeight, savedX, savedY;
  if (!getWindowSettings(savedWidth, savedHeight, savedX, savedY)) {
    // No saved window settings, position in center of target monitor
    savedWidth = 800;
    savedHeight = 600;
    savedX = monitorX + (mode->width - savedWidth) / 2;
    savedY = monitorY + (mode->height - savedHeight) / 2;
  }

  // Ensure the window is within the target monitor bounds
  savedX =
      std::max(monitorX, std::min(savedX, monitorX + mode->width - savedWidth));
  savedY = std::max(monitorY,
                    std::min(savedY, monitorY + mode->height - savedHeight));

  // Set window position and size
  glfwSetWindowPos(window, savedX, savedY);
  glfwSetWindowSize(window, savedWidth, savedHeight);

  std::cout << "Restored window to monitor " << lastMonitorIndex
            << " at position (" << savedX << ", " << savedY << ") with size ("
            << savedWidth << "x" << savedHeight << ")" << std::endl;

  return true;
}

void Settings::saveWindowSettings(int width, int height, int xPos, int yPos) {
  setSetting("window_width", width);
  setSetting("window_height", height);
  setSetting("window_x", xPos);
  setSetting("window_y", yPos);
}

bool Settings::getWindowSettings(int &width, int &height, int &xPos,
                                 int &yPos) {
  width = getSetting("window_width", 800);
  height = getSetting("window_height", 600);
  xPos = getSetting("window_x", 100);
  yPos = getSetting("window_y", 100);

  // Return true if we actually found saved settings
  return settings.find("window_width") != settings.end();
}

int Settings::getLastMonitorIndex() {
  return getSetting("last_monitor_index", -1);
}

void Settings::setLastMonitorIndex(int monitorIndex) {
  setSetting("last_monitor_index", monitorIndex);
}

void Settings::saveCurrentWindowState(GLFWwindow *window) {
  saveMonitorSettings(window);
}

void Settings::save() { saveToFile(); }

void Settings::load() {
  if (!loadFromFile()) {
    // Create default settings if file doesn't exist
    createDefaultSettings();
    saveToFile();
  }
}